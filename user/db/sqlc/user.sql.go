// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: user.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addConnection = `-- name: AddConnection :exec
insert into "connection" (
    user_1,
    user_2
) values ($1, $2)
`

type AddConnectionParams struct {
	User1 uuid.UUID `json:"user1"`
	User2 uuid.UUID `json:"user2"`
}

func (q *Queries) AddConnection(ctx context.Context, arg AddConnectionParams) error {
	_, err := q.db.ExecContext(ctx, addConnection, arg.User1, arg.User2)
	return err
}

const createUser = `-- name: CreateUser :one
insert into "user" (
    name,
    email,
    field,
    field_title,
    acc_type,
    password,
    country
)
values (
    $1, $2, $3, $4, $5, $6, $7
) returning id, name, country, dob, email, field, field_title, bio, password, acc_type, avatar_url, avatar_id, in_link, tw_link, wb_link, gb_link, active, valid, connections, created_at, updated_at
`

type CreateUserParams struct {
	Name       string `json:"name"`
	Email      string `json:"email"`
	Field      string `json:"field"`
	FieldTitle string `json:"fieldTitle"`
	AccType    string `json:"accType"`
	Password   string `json:"password"`
	Country    string `json:"country"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.Name,
		arg.Email,
		arg.Field,
		arg.FieldTitle,
		arg.AccType,
		arg.Password,
		arg.Country,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Country,
		&i.Dob,
		&i.Email,
		&i.Field,
		&i.FieldTitle,
		&i.Bio,
		&i.Password,
		&i.AccType,
		&i.AvatarUrl,
		&i.AvatarID,
		&i.InLink,
		&i.TwLink,
		&i.WbLink,
		&i.GbLink,
		&i.Active,
		&i.Valid,
		&i.Connections,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteConnection = `-- name: DeleteConnection :exec
delete from "connection"
 where id = $1
`

func (q *Queries) DeleteConnection(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteConnection, id)
	return err
}

const deleteReq = `-- name: DeleteReq :exec
delete from "request"
 where id = $1
`

func (q *Queries) DeleteReq(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteReq, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
 delete from "user"
  where id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getAllSentReq = `-- name: GetAllSentReq :many
select id, user_from, user_to, created_at
  from "request"
 where user_from = $1
 limit $2
 offset $3
`

type GetAllSentReqParams struct {
	UserFrom uuid.UUID `json:"userFrom"`
	Limit    int32     `json:"limit"`
	Offset   int32     `json:"offset"`
}

func (q *Queries) GetAllSentReq(ctx context.Context, arg GetAllSentReqParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getAllSentReq, arg.UserFrom, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserFrom,
			&i.UserTo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserConnections = `-- name: GetAllUserConnections :many
select id, user_1, user_2, blocked, created_at from "connection"
where user_1 = $1
or user_2 = $1
limit $2
offset $3
`

type GetAllUserConnectionsParams struct {
	User1  uuid.UUID `json:"user1"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetAllUserConnections(ctx context.Context, arg GetAllUserConnectionsParams) ([]Connection, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserConnections, arg.User1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Connection{}
	for rows.Next() {
		var i Connection
		if err := rows.Scan(
			&i.ID,
			&i.User1,
			&i.User2,
			&i.Blocked,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUserReq = `-- name: GetAllUserReq :many
select id, user_from, user_to, created_at
  from "request"
 where user_to = $1
 limit $2
 offset $3
`

type GetAllUserReqParams struct {
	UserTo uuid.UUID `json:"userTo"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) GetAllUserReq(ctx context.Context, arg GetAllUserReqParams) ([]Request, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserReq, arg.UserTo, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Request{}
	for rows.Next() {
		var i Request
		if err := rows.Scan(
			&i.ID,
			&i.UserFrom,
			&i.UserTo,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUsers = `-- name: GetAllUsers :many
select id, name, country, dob, email, field, field_title, bio, password, acc_type, avatar_url, avatar_id, in_link, tw_link, wb_link, gb_link, active, valid, connections, created_at, updated_at
  from "user"
  order by  id
  limit $1
  offset $2
`

type GetAllUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllUsers(ctx context.Context, arg GetAllUsersParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, getAllUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Country,
			&i.Dob,
			&i.Email,
			&i.Field,
			&i.FieldTitle,
			&i.Bio,
			&i.Password,
			&i.AccType,
			&i.AvatarUrl,
			&i.AvatarID,
			&i.InLink,
			&i.TwLink,
			&i.WbLink,
			&i.GbLink,
			&i.Active,
			&i.Valid,
			&i.Connections,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConnection = `-- name: GetConnection :one
select id, user_1, user_2, blocked, created_at from "connection"
where id = $1
limit 1
`

func (q *Queries) GetConnection(ctx context.Context, id uuid.UUID) (Connection, error) {
	row := q.db.QueryRowContext(ctx, getConnection, id)
	var i Connection
	err := row.Scan(
		&i.ID,
		&i.User1,
		&i.User2,
		&i.Blocked,
		&i.CreatedAt,
	)
	return i, err
}

const getReq = `-- name: GetReq :one
select id, user_from, user_to, created_at
  from "request"
 where id = $1
 limit 1
`

func (q *Queries) GetReq(ctx context.Context, id uuid.UUID) (Request, error) {
	row := q.db.QueryRowContext(ctx, getReq, id)
	var i Request
	err := row.Scan(
		&i.ID,
		&i.UserFrom,
		&i.UserTo,
		&i.CreatedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
select id, name, country, dob, email, field, field_title, bio, password, acc_type, avatar_url, avatar_id, in_link, tw_link, wb_link, gb_link, active, valid, connections, created_at, updated_at
  from "user"
 where id = $1
 limit 1
`

func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Country,
		&i.Dob,
		&i.Email,
		&i.Field,
		&i.FieldTitle,
		&i.Bio,
		&i.Password,
		&i.AccType,
		&i.AvatarUrl,
		&i.AvatarID,
		&i.InLink,
		&i.TwLink,
		&i.WbLink,
		&i.GbLink,
		&i.Active,
		&i.Valid,
		&i.Connections,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isEmailTaken = `-- name: IsEmailTaken :one
select id, name, country, dob, email, field, field_title, bio, password, acc_type, avatar_url, avatar_id, in_link, tw_link, wb_link, gb_link, active, valid, connections, created_at, updated_at
  from "user"
 where email = $1
`

func (q *Queries) IsEmailTaken(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, isEmailTaken, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Country,
		&i.Dob,
		&i.Email,
		&i.Field,
		&i.FieldTitle,
		&i.Bio,
		&i.Password,
		&i.AccType,
		&i.AvatarUrl,
		&i.AvatarID,
		&i.InLink,
		&i.TwLink,
		&i.WbLink,
		&i.GbLink,
		&i.Active,
		&i.Valid,
		&i.Connections,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const sendReq = `-- name: SendReq :exec
insert into "request" (
    user_from,
    user_to
) values (
    $1, $2
)
`

type SendReqParams struct {
	UserFrom uuid.UUID `json:"userFrom"`
	UserTo   uuid.UUID `json:"userTo"`
}

func (q *Queries) SendReq(ctx context.Context, arg SendReqParams) error {
	_, err := q.db.ExecContext(ctx, sendReq, arg.UserFrom, arg.UserTo)
	return err
}

const setActivity = `-- name: SetActivity :exec
update "user"
   set active=$2
 where id = $1
`

type SetActivityParams struct {
	ID     uuid.UUID `json:"id"`
	Active bool      `json:"active"`
}

func (q *Queries) SetActivity(ctx context.Context, arg SetActivityParams) error {
	_, err := q.db.ExecContext(ctx, setActivity, arg.ID, arg.Active)
	return err
}

const updateAvatar = `-- name: UpdateAvatar :exec
update "user"
   set avatar_url=$2,
   avatar_id=$3,
   updated_at=$4
 where id = $1
`

type UpdateAvatarParams struct {
	ID        uuid.UUID      `json:"id"`
	AvatarUrl sql.NullString `json:"avatarUrl"`
	AvatarID  sql.NullString `json:"avatarID"`
	UpdatedAt time.Time      `json:"updatedAt"`
}

func (q *Queries) UpdateAvatar(ctx context.Context, arg UpdateAvatarParams) error {
	_, err := q.db.ExecContext(ctx, updateAvatar,
		arg.ID,
		arg.AvatarUrl,
		arg.AvatarID,
		arg.UpdatedAt,
	)
	return err
}

const updateBio = `-- name: UpdateBio :exec
update "user"
    set bio=$2,
   updated_at=$3
  where id = $1
`

type UpdateBioParams struct {
	ID        uuid.UUID      `json:"id"`
	Bio       sql.NullString `json:"bio"`
	UpdatedAt time.Time      `json:"updatedAt"`
}

func (q *Queries) UpdateBio(ctx context.Context, arg UpdateBioParams) error {
	_, err := q.db.ExecContext(ctx, updateBio, arg.ID, arg.Bio, arg.UpdatedAt)
	return err
}

const updateConnectionTotal = `-- name: UpdateConnectionTotal :exec
update "user"
   set connections= connections + $2
 where id = $1
`

type UpdateConnectionTotalParams struct {
	ID          uuid.UUID `json:"id"`
	Connections int32     `json:"connections"`
}

func (q *Queries) UpdateConnectionTotal(ctx context.Context, arg UpdateConnectionTotalParams) error {
	_, err := q.db.ExecContext(ctx, updateConnectionTotal, arg.ID, arg.Connections)
	return err
}

const updateEmail = `-- name: UpdateEmail :exec
update "user"
   set email=$2,
   updated_at=$3
 where id = $1
`

type UpdateEmailParams struct {
	ID        uuid.UUID `json:"id"`
	Email     string    `json:"email"`
	UpdatedAt time.Time `json:"updatedAt"`
}

func (q *Queries) UpdateEmail(ctx context.Context, arg UpdateEmailParams) error {
	_, err := q.db.ExecContext(ctx, updateEmail, arg.ID, arg.Email, arg.UpdatedAt)
	return err
}

const updateOther = `-- name: UpdateOther :exec
update "user"
   set in_link=$2,
   tw_link=$3,
   wb_link=$4,
   gb_link=$5,
   updated_at=$6
 where id = $1
`

type UpdateOtherParams struct {
	ID        uuid.UUID      `json:"id"`
	InLink    sql.NullString `json:"inLink"`
	TwLink    sql.NullString `json:"twLink"`
	WbLink    sql.NullString `json:"wbLink"`
	GbLink    sql.NullString `json:"gbLink"`
	UpdatedAt time.Time      `json:"updatedAt"`
}

func (q *Queries) UpdateOther(ctx context.Context, arg UpdateOtherParams) error {
	_, err := q.db.ExecContext(ctx, updateOther,
		arg.ID,
		arg.InLink,
		arg.TwLink,
		arg.WbLink,
		arg.GbLink,
		arg.UpdatedAt,
	)
	return err
}

const updatePassword = `-- name: UpdatePassword :exec
update "user"
   set password=$2
 where id = $1
`

type UpdatePasswordParams struct {
	ID       uuid.UUID `json:"id"`
	Password string    `json:"password"`
}

func (q *Queries) UpdatePassword(ctx context.Context, arg UpdatePasswordParams) error {
	_, err := q.db.ExecContext(ctx, updatePassword, arg.ID, arg.Password)
	return err
}

const validate = `-- name: Validate :exec
update "user"
    set valid=$2
 where id = $1
`

type ValidateParams struct {
	ID    uuid.UUID `json:"id"`
	Valid bool      `json:"valid"`
}

func (q *Queries) Validate(ctx context.Context, arg ValidateParams) error {
	_, err := q.db.ExecContext(ctx, validate, arg.ID, arg.Valid)
	return err
}
